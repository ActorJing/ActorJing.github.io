{"meta":{"title":"我超爱大海的","subtitle":"世界很暗，但是你来了","description":"","author":"Jing Wu","url":"https://actorjing.github.io","root":"/"},"pages":[{"title":"关于我","date":"2024-01-14T13:55:32.000Z","updated":"2024-07-05T15:46:06.546Z","comments":true,"path":"about/index.html","permalink":"https://actorjing.github.io/about/index.html","excerpt":"","text":"我的故事你听说过我的故事？ “我的计划是一直自由 直到陪伴胜过我独活” 注：这是我的座右铭。 联系我： 邮箱：wujing.ahtcm.gmail.com GitHub：ActorJing bilibili：迪斯尼海滩空想家 项目展示： 项目名称 描述 项目1 项目1的简短描述 项目2 项目2的简短描述 教育经历： 硕士，计算机技术，合肥工业大学，2022 学士，医学信息工程，安徽中医药大学，2018 技能列表： 单片机开发51、STM32、NXP、TC264；嵌入式Linux、I.MX6ULL PID控制、模糊控制、FOC控制 Altium Designer、立创eda 个人兴趣： 骑行 摄影"},{"title":"书单","date":"2024-07-05T06:07:09.000Z","updated":"2024-07-06T15:14:05.133Z","comments":true,"path":"book/index.html","permalink":"https://actorjing.github.io/book/index.html","excerpt":"","text":"大语言模型Linux驱动DSP算法"},{"title":"friends","date":"2024-01-18T07:31:09.000Z","updated":"2024-01-18T07:31:25.284Z","comments":true,"path":"friends/index.html","permalink":"https://actorjing.github.io/friends/index.html","excerpt":"","text":""},{"title":"分类","date":"2024-01-14T13:51:15.000Z","updated":"2024-07-05T15:37:35.703Z","comments":true,"path":"categories/index.html","permalink":"https://actorjing.github.io/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2024-01-18T07:24:41.000Z","updated":"2024-01-18T07:25:12.446Z","comments":true,"path":"contact/index.html","permalink":"https://actorjing.github.io/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2024-07-05T15:11:33.000Z","updated":"2024-07-05T15:11:43.244Z","comments":true,"path":"tags/index.html","permalink":"https://actorjing.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2025.3.8南京植物园","slug":"2025-3-8南京植物园","date":"2025-03-10T08:38:55.000Z","updated":"2025-03-10T08:49:02.979Z","comments":true,"path":"2025/03/10/2025-3-8南京植物园/","link":"","permalink":"https://actorjing.github.io/2025/03/10/2025-3-8%E5%8D%97%E4%BA%AC%E6%A4%8D%E7%89%A9%E5%9B%AD/","excerpt":"","text":"2025.3.8南京植物园有盛开的樱花，待放的郁金香，热带植物园，还有","categories":[{"name":"摄影日记","slug":"摄影日记","permalink":"https://actorjing.github.io/categories/%E6%91%84%E5%BD%B1%E6%97%A5%E8%AE%B0/"}],"tags":[]},{"title":"ESP32_RTOS日志","slug":"ESP32-RTOS日志","date":"2024-10-11T14:36:25.000Z","updated":"2024-10-11T14:42:28.511Z","comments":true,"path":"2024/10/11/ESP32-RTOS日志/","link":"","permalink":"https://actorjing.github.io/2024/10/11/ESP32-RTOS%E6%97%A5%E5%BF%97/","excerpt":"","text":"ESP32S3-RTOS日志1.ESP32S3双核不使用RTOS下，默认在核1运行，核0使用wifi和蓝牙，使用RTOS时，任务会自动在两核心调度 configNUMBER_OF_CORES 配置RTOS核心个数（了解即可） 2.IWDT和TWDT外部中断看门狗和任务看门狗 理解为硬复位和软复位，任务看门狗默认打开，在设置时搜多WDT找到task wdt关闭或打开","categories":[],"tags":[]},{"title":"嵌入式八股文.md","slug":"嵌入式八股文","date":"2024-09-18T13:15:23.000Z","updated":"2025-03-23T11:32:37.691Z","comments":true,"path":"2024/09/18/嵌入式八股文/","link":"","permalink":"https://actorjing.github.io/2024/09/18/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%85%AB%E8%82%A1%E6%96%87/","excerpt":"","text":"SPI串行，四线：CLK，MISO，MOSI，CS 允许一个主机多个从机 SPI有四种操作模式，对应时钟极性和时钟相位 CPOL表示CLK的空闲状态有效电平，0空闲低电平，1空闲高电平 CPHA数据采样时间，0表示第一个跳变沿，1表示第二个跳变沿 配置SPI传输速度分频值和系统时钟 UART串行，TX，RX IICSDA,SCL，同步串行，支持多设备 起始条件：SCL高，SDA下降沿 停止条件：SCL高，SDA上升沿 ETH以太网，局域网通信协议使用MAC地址进行设备寻址 TCP&#x2F;IP协议层次结构： 应用层，传输层，网络层，数据链路层，物理层 递归函数定义没有问题，递归深层次后易引发什么问题影响执行效率 栈溢出。 因为每一次调用函数是，栈区都要给函数分配空间，而且上一次调用并没有结束，调用的次数太多，栈区的内存不够分配了，便会出现栈溢出的情况。 堆与栈的区别（1）栈的空间是系统自动分配和回收，堆的空间是用户手动分配回收（malloc，calloc，realloc，free） （2）栈的空间较小，堆的空间较大 （3）栈的地址空间往地址向下增长，堆的地址空间是由低地址到高地址 （4）栈的存储效率更高 PV操作申请资源 释放资源一般用于同步和互斥 什么是嵌入式系统完全嵌入受控器件内部、为特定应用而设计的专用计算机系统。与普通计算机不同，嵌入式系统一般拥有非常有限的硬件资源，一般运行固定的程序或固定的操作系统加可变的应用程序。 volatile关键字的作用（1）裸机编程时，某变量是指向寄存器中某一特定地址，添加volatile的变量不进行优化处理； （2）某函数与中断函数共享全局变量时，加上volatile，让编译器不要省略该变量的访问； （3）多线程中修饰共享全局变量，让编译器不要省略该变量的访问。 FREERTOS操作系统完全免费且开源的嵌入式实时操作系统 抢占式（pre-emptive）或合作式（co-operative）任务调度方式 优先级管理 任务通知机制 消息队列 信号量 启动流程：RTOS系统初始化。比如RTOS里面的全局变量的初始化，空闲任务的创建等。创建各种任务。启动RTOS调度器 FreeRTOS如何实现实时性优先级抢占式调度策略+时间片轮转 优先级高的任务可以抢占优先级低的任务，同等级别的任务时间片轮转 时间片轮转根据系统节拍频率决定：configTICK_RATE_HZ 系统中存在一个空闲任务，当没有其他任务运行时，系统会执行空闲任务 FreeRTOS同步与通信信号量 xSemaphoreGive() 释放信号量，xSemaphoreTake() 获取信号量。 互斥量 二进制信号量，用于互斥事件 消息队列 xQueueSend() 发送数据，xQueueReceive() 接收数据。 事件组 是一个32位的变量，每一位表示一个事件，支持多事件同步 使用事件组创建状态机： void vTask(void *pvParameters) { EventBits_t uxBits; while (1) { uxBits = xEventGroupWaitBits(xEventGroup, 0x03, pdTRUE, pdTRUE, portMAX_DELAY); if ((uxBits &amp; 0x01) { // 状态 1 } else if ((uxBits &amp; 0x02)) { // 状态 2 } } } 生产者消费者生产者-消费者模型是一个经典的并发控制问题，用来解决在多线程环境中，生产者线程和消费者线程之间的同步问题。生产者负责生产数据并将其放入缓冲区，而消费者则从缓冲区中取出数据进行处理。为了防止生产者和消费者之间的竞争，通常使用同步机制来控制访问缓冲区。 缓冲区： 一个有限的共享空间，用于存储生产者生产的产品。可以是一个队列、数组等。 生产者： 负责将产品生产并放入缓冲区。当缓冲区满时，生产者需要等待。 消费者： 负责从缓冲区中取出产品并进行处理。当缓冲区空时，消费者需要等待。 同步机制： 使用互斥锁（mutex）和条件变量（condition variable）来确保生产者和消费者对缓冲区的访问是安全的，并解决同步问题。 使用malloc和free过程中如何避免野指针的产生1、初始化指针为NULL 2、分配内存后检查返回值 3、释放内存后将指针置为NULL 4、避免多次释放同一个指针 MQTT 通信过程1、建立连接（客户端使用唯一的客户端ID） 2、订阅主题（主题是分层结构的字符串） 3、发布消息（QoS0：最多发送一次，不保证成功；QoS1：至少发送一次，可能重复；QoS2：确保发送一次，防止重复） 4、消息接收 5、断开连接 ADC配置步骤1、启动ADC时钟 2、配置ADC的引脚和通道 3、设置ADC分辨率（8，10，12） 4、设置ADC的时钟分频器（采样频率） 5、配置转换模式（单次，连续，TIM触发） 宏定义和内敛函数的区别 访问百度发生了什么1、域名解析，浏览器在缓存中查找是否有对应的IP地址，没有会向DNS服务器发起查询，获取对应IP地址 2、建立TCP连接 3、发送HTTP请求，获取网页内容 4、服务器处理请求，返回响应 5、浏览器解析HTML，渲染网页 DNS解析DNS是一个分布式的数据库系统，将域名与IP进行映射 1、检查浏览器本地缓存，操作系统缓存，本地hosts文件 2、向本地DNS服务器检查缓存，一般由网络服务运营商提供或者自己设置 3、迭代向更高级的DNS服务器查询 优化：缓存机制，负载均衡（服务器多个IP，根据区域返回最近的），公共DNS FREERTOS和Linux的内存分配区别freertos基于任务堆栈的分配和使用，每个任务有自己的栈空间，在任务创建时静态分配 Linux使用动态内存管理，采用虚拟内存系统，进程之前的内存相互隔离，不同进程无法直接访问对方内存 DMADMA是一个硬件模块，负责数据搬运，CPU只需初始化DMA配置启动传输后，可以执行其他任务。以SPI为例： 不使用DMA时，CPU需要将数据写入到SPI的数据寄存器，等待SPI发送完成再写入下一个数据。 使用DMA时，CPU配置好SPI和DMA控制器，设置数据源地址和目标地址以及传输长度，启动传输后，CPU直接从内存取数据并通过SPI将数据发送出去，此过程无需CPU参与，DMA传输完成后会触发一个中断，CPU可以执行操作。数据准备好后会产生一个DMA请求信号，是硬件信号，触发DMA搬运数据。 使用联合体判断大小端#include &lt;stdio.h> // 定义联合体 union EndianTest { int value; // 4 字节的整数 char bytes[4]; // 1 字节的字符数组 }; int main() { union EndianTest test; test.value = 0x01020304; // 设置一个多字节值 // 检查低地址字节的值 if (test.bytes[0] == 0x04) { printf(\"Little Endian\\n\"); // 低地址存储低位字节 } else if (test.bytes[0] == 0x01) { printf(\"Big Endian\\n\"); // 低地址存储高位字节 } else { printf(\"Unknown Endian\\n\"); // 其他情况 } return 0; } typedef和define的区别typedef是为一个已经存在的数据类型取一个别名，编译器会进行类型检查 define是宏定义，在预编译阶段进行替换 sizeof和strlen的区别sizeof返回变量或类型的字节大小 strlen返回字符串的长度 ESP32支持wifi模式sta：连接到wifi网络 ap：作为热点 可以同时使用","categories":[],"tags":[]},{"title":"c++数据结构","slug":"c-数据结构","date":"2024-07-20T15:09:10.000Z","updated":"2024-07-21T05:42:46.325Z","comments":true,"path":"2024/07/20/c-数据结构/","link":"","permalink":"https://actorjing.github.io/2024/07/20/c-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"c++数据结构平衡二叉树","categories":[{"name":"算法","slug":"算法","permalink":"https://actorjing.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"野火H7PRO+RGB565屏幕+LTDC+SDRAM+DMA2D+FreeRTOS+LVGL","slug":"野火H7PRO+RGB565屏幕+LTDC+SDRAM+DMA2D+FreeRTOS+LVGL","date":"2024-07-16T15:27:23.000Z","updated":"2024-07-16T12:31:28.174Z","comments":true,"path":"2024/07/16/野火H7PRO+RGB565屏幕+LTDC+SDRAM+DMA2D+FreeRTOS+LVGL/","link":"","permalink":"https://actorjing.github.io/2024/07/16/%E9%87%8E%E7%81%ABH7PRO+RGB565%E5%B1%8F%E5%B9%95+LTDC+SDRAM+DMA2D+FreeRTOS+LVGL/","excerpt":"","text":"野火H7PRO+RGB565屏幕+LTDC+SDRAM+DMA2D+FreeRTOS+LVGL时钟配置，功率优化设置为0，设置主频480M，FMC240M，LTDC50M 野火开发板使用FMC的CKE1连接SDRAM使用bank2，地址为0xD0000000，cubemx配置如下：（注意GPIO，一开始使用bank1刷图正常，画点错误，发现是IO配置错误，理论上刷图也会报错） 配置LTDC：（需要注意引脚IO，参数对应数据手册，LTDC有背景层，图层1和图层2，本工程只使用图层1） 数据手册如下： cubemx配置DMA2D： 生成工程后，先初始化FMC，再配置SDRAM自动刷新命令，最后初始化LTDC： static FMC_SDRAM_CommandTypeDef Command; #define FMC_COMMAND_TARGET_BANK FMC_SDRAM_CMD_TARGET_BANK2 SDRAM_HandleTypeDef hsdram1; #define SDRAM_TIMEOUT ((uint32_t)0xFFFF) /** * @brief 延迟一段时间 * @param 延迟的时间长度 * @retval None */ static void SDRAM_delay(__IO uint32_t nCount) { __IO uint32_t index = 0; for(index = (100000 * nCount); index != 0; index--) { } } /** * @brief 对SDRAM芯片进行初始化配置 * @param None. * @retval None. */ static void SDRAM_InitSequence(void) { uint32_t tmpr = 0; /* Step 1 ----------------------------------------------------------------*/ /* 配置命令：开启提供给SDRAM的时钟 */ Command.CommandMode = FMC_SDRAM_CMD_CLK_ENABLE; Command.CommandTarget = FMC_COMMAND_TARGET_BANK; Command.AutoRefreshNumber = 1; Command.ModeRegisterDefinition = 0; /* 发送配置命令 */ HAL_SDRAM_SendCommand(&amp;sdramHandle, &amp;Command, SDRAM_TIMEOUT); /* Step 2: 延时100us */ SDRAM_delay(1); /* Step 3 ----------------------------------------------------------------*/ /* 配置命令：对所有的bank预充电 */ Command.CommandMode = FMC_SDRAM_CMD_PALL; Command.CommandTarget = FMC_COMMAND_TARGET_BANK; Command.AutoRefreshNumber = 1; Command.ModeRegisterDefinition = 0; /* 发送配置命令 */ HAL_SDRAM_SendCommand(&amp;sdramHandle, &amp;Command, SDRAM_TIMEOUT); /* Step 4 ----------------------------------------------------------------*/ /* 配置命令：自动刷新 */ Command.CommandMode = FMC_SDRAM_CMD_AUTOREFRESH_MODE; Command.CommandTarget = FMC_COMMAND_TARGET_BANK; Command.AutoRefreshNumber = 8; Command.ModeRegisterDefinition = 0; /* 发送配置命令 */ HAL_SDRAM_SendCommand(&amp;sdramHandle, &amp;Command, SDRAM_TIMEOUT); /* Step 5 ----------------------------------------------------------------*/ /* 设置sdram寄存器配置 */ tmpr = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_1 | SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL | SDRAM_MODEREG_CAS_LATENCY_3 | SDRAM_MODEREG_OPERATING_MODE_STANDARD | SDRAM_MODEREG_WRITEBURST_MODE_SINGLE; /* 配置命令：设置SDRAM寄存器 */ Command.CommandMode = FMC_SDRAM_CMD_LOAD_MODE; Command.CommandTarget = FMC_COMMAND_TARGET_BANK; Command.AutoRefreshNumber = 1; Command.ModeRegisterDefinition = tmpr; /* 发送配置命令 */ HAL_SDRAM_SendCommand(&amp;sdramHandle, &amp;Command, SDRAM_TIMEOUT); /* Step 6 ----------------------------------------------------------------*/ /* 设置刷新计数器 */ /* 刷新周期=64ms/8192行=7.8125us */ /* COUNT=(7.8125us x Freq) - 20 */ /* 设置自刷新速率 */ HAL_SDRAM_ProgramRefreshRate(&amp;sdramHandle, 824); } 参考这篇博客LTDC测试时先测试背景层显示是否正常，再初始化SDRAM测试图层，注意显存地址，黑屏表示SDRAM初始化存在问题，白屏正常再测试画点，画点存在问题说明FMC块配置存在问题。 DMA传输数据： static void dma2d_transfer_data_r2m(uint32_t *addr, uint32_t xSize, uint32_t ySize, uint32_t offsetLine, uint16_t color) { DMA2D->CR = DMA2D_R2M; // dma2d mode: register to memory. DMA2D->OPFCCR = DMA2D_OUTPUT_RGB565; DMA2D->OCOLR = color; DMA2D->OMAR = (uint32_t)addr; DMA2D->OOR = offsetLine; DMA2D->NLR = (uint32_t)(xSize &lt;&lt; 16) | (uint16_t)ySize; // DMA2D->NLR = (uint32_t)(xSize * ySize); DMA2D->CR |= DMA2D_CR_START; while (DMA2D->CR &amp; DMA2D_CR_START); } void lcd_clear(uint16_t color) { dma2d_transfer_data_r2m((uint32_t *)LCD_FRAME_BUFFER, LCD_WIDTH, LCD_HEIGHT, 0, color); // uint16_t *ptr = (uint16_t*)LCD_FRAME_BUFFER; // uint32_t i = 0; // while (i++ &lt; LCD_WIDTH*LCD_HEIGHT) { // *(ptr+i) = color; // } } void lcd_draw_point(uint16_t x, uint16_t y, uint16_t color) { uint32_t pos; uint16_t *ptr; // check position. if (x > LCD_WIDTH || y > LCD_HEIGHT) { return; } // calculate the position offset in framebuffer. pos = x + y*LCD_WIDTH; ptr = (uint16_t*)LCD_FRAME_BUFFER; // modify the framebuffer. dma2d_transfer_data_r2m((uint32_t *)(ptr+pos), 1, 1, 0, color); } LVGL移植：使用lvgl8.3.10，适配GUI GUIDER版本 在keil工程中新建lvgl组，将src目录下所有的c和h文件添加到该组中，注意是所有的c和h文件，包括子目录中的！ 在keil工程中新建lvgl_port组，将examples\\porting中的disp和indev文件（显示屏和外设，文件系统未使用）和lvgl.h，lv_conf.h放在该组中： 编译可能会出现的问题和解决方法（stderr断言缺失）： LVGL运行需要1ms心跳，FreeRTOS的频率为1000Hz正好为1ms，lvgl中有FreeRTOS钩子函数，需要在配置文件中打开，注意这里不要使用cubemx勾选，否则会创建一个新的钩子函数，重新生成工程时需要再配置一下。 lv_port_disp.c实现画点函数： static void disp_flush(lv_disp_drv_t * disp_drv, const lv_area_t * area, lv_color_t * color_p) { if(disp_flush_enabled) { /*The most simple case (but also the slowest) to put all pixels to the screen one-by-one*/ int32_t x; int32_t y; for(y = area->y1; y &lt;= area->y2; y++) { for(x = area->x1; x &lt;= area->x2; x++) { /*Put a pixel to the display. For example:*/ lcd_draw_point(x,y, color_p->full); color_p++; } } } /*IMPORTANT!!! *Inform the graphics library that you are ready with the flushing*/ lv_disp_flush_ready(disp_drv); } lv_port_indev.c实现触摸屏坐标读取，这里遇到一个坑，GT9157的寄存器地址和GT911一模一样，程序使用GT911： /*Will be called by the library to read the touchpad*/ static void touchpad_read(lv_indev_drv_t * indev_drv, lv_indev_data_t * data) { static lv_coord_t last_x = 0; static lv_coord_t last_y = 0; /*Save the pressed coordinates and the state*/ if(touchpad_is_pressed()) { touchpad_get_xy(&amp;last_x, &amp;last_y); data->state = LV_INDEV_STATE_PR; } else { data->state = LV_INDEV_STATE_REL; } /*Set the last pressed coordinates*/ data->point.x = last_x; data->point.y = last_y; } /*Return true is the touchpad is pressed*/ static bool touchpad_is_pressed() { uint8_t temp = 0; /*Your code comes here*/ GT911_ReadReg(GT_GSTID_REG, &amp;temp, 1); if (temp &amp; 0x80) { if(temp &amp; 0x0F){ return true; } temp = 0; GT911_WriteReg(GT_GSTID_REG, &amp;temp, 1); } // ESP_LOGI(TAG, \"temp=0x%X\",temp); return false; } /*Get the x and y coordinates if the touchpad is pressed*/ static void touchpad_get_xy(lv_coord_t * x, lv_coord_t * y) { /*Your code comes here*/ uint8_t data[4]; u8 Data_length; u8 Read_buff[20]; GT911_ReadReg(GT_TP1_REG, data, 4); *x = ((data[1] &amp; 0x0f) &lt;&lt; 8) + data[0]; *y = (((data[3] &amp; 0x0f) &lt;&lt; 8) + data[2]); data[0] = 0; GT911_WriteReg(GT_GSTID_REG, data, 1); } 最后打开显示和外设文件的开关，编译。 如果存在#include “lvgl&#x2F;lvgl.h”报错，修改为#include “lvgl.h” GUI GUIDER的移植只需要拷贝custom和generated文件夹，添加所有文件，头文件修改为#include “lvgl.h”，如果使用了其他图形插件，需要手动添加 GUI GUIDER运行，先初始化lvgl，显示屏，外设，再初始化GUI，循环调用lv_timer_handler()处理函数： /* USER CODE END Header_StartDefaultTask */ void StartDefaultTask(void *argument) { /* USER CODE BEGIN StartDefaultTask */ lv_init(); lv_port_disp_init(); lv_port_indev_init(); setup_ui(&amp;guider_ui); events_init(&amp;guider_ui); /* Infinite loop */ for(;;) { lv_timer_handler(); osDelay(5); } /* USER CODE END StartDefaultTask */ } 工程源码地址本工程生成时使用ARM V6编译器，官方cubemx生成直接使用v6编译器会报错，需要修改PACK包中的RTOS文件","categories":[{"name":"ARM嵌入式","slug":"ARM嵌入式","permalink":"https://actorjing.github.io/categories/ARM%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[]},{"title":"使用Matlab进行信号处理","slug":"使用Matlab进行信号处理","date":"2024-07-16T12:43:04.000Z","updated":"2024-07-16T13:29:04.398Z","comments":true,"path":"2024/07/16/使用Matlab进行信号处理/","link":"","permalink":"https://actorjing.github.io/2024/07/16/%E4%BD%BF%E7%94%A8Matlab%E8%BF%9B%E8%A1%8C%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/","excerpt":"","text":"使用Matlab对单片机采样信号进行分析处理和滤波条件：单片机和PC在同一网段，可以使用wifi或者网卡，且已知单片机的信号采样率 单片机作为TCP客户端，matlab创建TCP服务端，等待客户端连接，读取指定数据量，程序如下： IP = '192.168.2.3'; PORT = 6802; SampleCount = 10200; % 4字节float类型 t_server = tcpserver(IP, PORT); fopen(t_server); % 初始化一个空数组用于存储读取的数据 data = []; while(1) % 检查是否有可用的数据 if t_server.BytesAvailable >= 4*SampleCount % 每次读取4个字节，总共需要读取10次 % 读取数据并转换为float类型 for i = 1:SampleCount data_recv = fread(t_server, 4, 'uint8'); % 将读取的数据添加到数组中 data = [data; str2double(char(data_recv))]; end break; end end plot(data); delete(t_server); 该程序指定服务端IP为192.168.2.3，端口为6802，获取10200个数据 注意：字节直接转换float存在问题，先转换成字符串再转换为浮点数正常对采样信号进行傅里叶变换，获取噪声的频率： clc close all; clear; % 加载data.mat文件 load('data.mat'); % 绘制data变量的图形 plot(data); % 生成信号 Fs = 1025.390625; % 采样频率 N = 10200; % 采样数 t = (0:N-1)/Fs; % 时间向量 f = (0:N-1)*(Fs/N); % 频率向量 % 进行傅里叶变换 Y = fft(data); % 计算双边频谱 P2 = abs(Y/N); % 计算单边频谱 P1 = P2(1:N/2+1); P1(2:end-1) = 2*P1(2:end-1); % 绘制频域图 figure; plot(f(1:N/2+1), P1); xlabel('Frequency (Hz)'); ylabel('Amplitude'); title('Frequency Domain of Data'); 根据噪声频率设计陷波滤波器： 实现模型，一定要勾选使用基本元素构建模型： 双击模型展开可以看到具体实现函数，-1表示上一刻值，K表示乘积： 根据函数和参数，使用代码实现即可实现滤波。 Matlab源码地址","categories":[{"name":"算法","slug":"算法","permalink":"https://actorjing.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"MDK使用ARMV6编译器","slug":"MDK使用ARMV6编译器","date":"2024-07-16T12:27:23.000Z","updated":"2024-07-16T12:36:15.636Z","comments":true,"path":"2024/07/16/MDK使用ARMV6编译器/","link":"","permalink":"https://actorjing.github.io/2024/07/16/MDK%E4%BD%BF%E7%94%A8ARMV6%E7%BC%96%E8%AF%91%E5%99%A8/","excerpt":"","text":"MDK使用ARMV6编译器 替换FreeRTOS文件：","categories":[{"name":"ARM嵌入式","slug":"ARM嵌入式","permalink":"https://actorjing.github.io/categories/ARM%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[]},{"title":"Typero连接阿里云oss","slug":"typero连接阿里云oss","date":"2024-07-16T12:27:23.000Z","updated":"2024-07-20T09:22:15.913Z","comments":true,"path":"2024/07/16/typero连接阿里云oss/","link":"","permalink":"https://actorjing.github.io/2024/07/16/typero%E8%BF%9E%E6%8E%A5%E9%98%BF%E9%87%8C%E4%BA%91oss/","excerpt":"","text":"Typero连接阿里云oss","categories":[{"name":"杂项","slug":"杂项","permalink":"https://actorjing.github.io/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[]},{"title":"储能一次调频方案","slug":"储能一次调频方案","date":"2024-07-07T14:12:34.000Z","updated":"2024-07-07T14:17:41.059Z","comments":true,"path":"2024/07/07/储能一次调频方案/","link":"","permalink":"https://actorjing.github.io/2024/07/07/%E5%82%A8%E8%83%BD%E4%B8%80%E6%AC%A1%E8%B0%83%E9%A2%91%E6%96%B9%E6%A1%88/","excerpt":"","text":"","categories":[{"name":"论文","slug":"论文","permalink":"https://actorjing.github.io/categories/%E8%AE%BA%E6%96%87/"}],"tags":[]},{"title":"储能一次调频文献","slug":"储能一次调频文献","date":"2024-07-07T13:26:37.000Z","updated":"2024-07-10T12:43:44.158Z","comments":true,"path":"2024/07/07/储能一次调频文献/","link":"","permalink":"https://actorjing.github.io/2024/07/07/%E5%82%A8%E8%83%BD%E4%B8%80%E6%AC%A1%E8%B0%83%E9%A2%91%E6%96%87%E7%8C%AE/","excerpt":"","text":"基于储能系统多重约束的一次调频策略_梁继业火电-储能一体化系统参与一次调频的方法研究_宋辉考虑SOC的电池储能系统一次调频策略研究_刘英培计及SOC的电池储能系统一次调频自适应综合控制策略_王育飞计及SOC的电池储能系统一次调频自适应综合控制策略附录基于SOC分区的蓄电池储能辅助热电机组调频控制策略研究","categories":[{"name":"论文","slug":"论文","permalink":"https://actorjing.github.io/categories/%E8%AE%BA%E6%96%87/"}],"tags":[]},{"title":"cubeMX使用LwIP","slug":"cubeMX使用LwIP","date":"2024-07-06T15:27:23.000Z","updated":"2024-07-06T15:36:55.126Z","comments":true,"path":"2024/07/06/cubeMX使用LwIP/","link":"","permalink":"https://actorjing.github.io/2024/07/06/cubeMX%E4%BD%BF%E7%94%A8LwIP/","excerpt":"","text":"cubeMX配置：","categories":[{"name":"ARM嵌入式","slug":"ARM嵌入式","permalink":"https://actorjing.github.io/categories/ARM%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[]},{"title":"笔记上传步骤","slug":"笔记上传步骤","date":"2024-07-06T14:58:34.000Z","updated":"2024-07-06T15:13:57.287Z","comments":true,"path":"2024/07/06/笔记上传步骤/","link":"","permalink":"https://actorjing.github.io/2024/07/06/%E7%AC%94%E8%AE%B0%E4%B8%8A%E4%BC%A0%E6%AD%A5%E9%AA%A4/","excerpt":"","text":"1、pdf文档放在book&#x2F;ebook目录下，同步git2、hexo创建笔记，上传git3、将整个hexoblog工程同步git","categories":[{"name":"笔记上传","slug":"笔记上传","permalink":"https://actorjing.github.io/categories/%E7%AC%94%E8%AE%B0%E4%B8%8A%E4%BC%A0/"}],"tags":[]},{"title":"工作日志","slug":"工作日志","date":"2024-07-05T13:57:10.000Z","updated":"2024-07-10T14:33:08.854Z","comments":true,"path":"2024/07/05/工作日志/","link":"","permalink":"https://actorjing.github.io/2024/07/05/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/","excerpt":"","text":"3.19搭建环境同步器程序设计 3.20同步器程序调试 发送多路同步脉冲出，单脉冲，持续脉冲 3.21同步器程序完成压力手掌分布接口布线鞋垫FPC接口设计 3.22足底采集电路布线完成鞋垫接口测试 3.25fpc连接接口设计完成ADC采集程序调试 右脚16pin在上 3.26-电路设计ADC电容尽量靠近单片机，ADC芯片到单片机的输入输出高阻抗，中间走线尽可能短-adc走线需要注意下电流-退藕电容尽量靠近芯片引脚-AGND和GND需要分离，使用磁珠 足底连接接口打板调试adc采集程序 3.27adc采集程序移植完成学习STM32H7 3.28学习STM32H7 ADC DMA DAC 3.29学习STM32H7 IIC CAN 4.1搭建ESP32环境熟悉足底压力程序 4.2调试足底压力程序加入WIFI信号强度检测 4.3调试足底压力adc采集逻辑 4.7-8足底程序编写完成 4.9-4.16测力台PCB设计完成重焊足底上板ADC芯片 AD 3.3VA还没有解决 ADC加滤波 4.17重焊足底上板ADC芯片，修好18片，一片不稳定（加热后第一次采集正常，之后全是0，可能出现FF），一片元件缺失测力台原理图更新，新增三色灯柱，急停开关，电机和传感器减少为16个 4.18PCB设计完成打样三色灯柱、急停开关选型 等待电路板的几天在学习步进电机驱动和LVGL 4.28完成步进电机加速到匀速过程，采用T型加减速adc采集未触发IO中断 4.29-30ADC外部中断触发正常，spi读取正常，写入存在问题spi写入MCP3914寄存器存在问题，读取寄存器数据全部为FF，读取adc正常 5.6调试spi，使用逻辑分析仪查看数据正常低速写入同样存在问题 5.7spi写入仍然存在问题，怀疑芯片上锁，boost配置问题，检查后仍然写入失败调试过程板子烧了，单独供电3.3V，3A红外测温发现STM32单片机烧了更换了单片机，adc只有第一次数据正常，后面保持不变，DR引脚触发正常，怀疑adc芯片也烧坏了，无多余芯片，未更换，调试备用板 5.8spi问题未解决，重新配置adc的时钟为1.05Madc采样频率为1050000&#x2F;4&#x2F;256&#x3D;1025.390625Hz人体触摸力传感器出现频率为50Hz的噪声，采用陷波滤波器 5.9测力台暂停标定台电机工作电磁干扰adc，更换电机 5.10电机更换完成学习DSP 5.11通过matlab建立tcp服务器，将adc数据发送到matlab通过傅里叶变换，找到人体触摸传感器时的噪声频率，通过matlab的滤波器设计功能，加入陷波滤波器，导出参数，对adc进行滤波，效果显著 5.13加入急停开关和三色灯柱接口测力台程序基本开发完成重构单独ADC采样程序，回到spi问题 5.14重构程序，找到spi写入adc错误原因adc芯片RSTn引脚默认低电平，导致adc芯片未工作 5.15-17移植gui guider程序到esp32中标定台mos烧了，修改电路，新增保险丝保险丝型号C6165156 请假两天 5.22esp32lvgl运行，触摸屏驱动采用定时查询机器人驱动器串口调试乱码 5.23板子到了，驱动信号线和使能反了，飞线测试程序正常运行，烧错程序导致烧了一块板子 5.24胶壳到了，给标定台压端子 5.27标定台维修完成，测试电机工作时温度45°，长时间工作无温升 5.28-6.14lvgl学习guiguider学习 6.17-6.21腕力传感器协调出现的问题和总结：板对板连接器焊接保留沉金使用可调电源供电时，设备功率大约在1W，46V供电初始电流尽可能小，怀疑电流浪涌导致设备烧毁5台熟悉放大器，调零电阻 6.22 加班腕力传感器标定软件设置adc量程错误，采样adc值超调，调整放大电阻还得调回去，等待软件修复 6.24软件修复，换回放大电阻标定3台设备编写生产文档，和生产协调标定过程 6.25和生产一起标定一台传感器文档上传医院项目电机商量，测试直线电机驱动器，使用官方调试线仍然通信失败，更换直线电机项目屏幕使用串口屏，购买屏幕测试 &#x2F;**********************************期间调试keil时，lvgl工程文件太多，编译实在太慢，更换V6编译器，使用lwip时出现的问题： 使用V6编译器编译rtos项目时需要更换库路径，lwip需要更换cc.h文件下宏定义：&#x2F;&#x2F;#if defined (GNUC) &amp; !defined (__CC_ARM)#if defined (GNUC) &amp;&amp; !defined (__CC_ARM) &amp;&amp; !(defined(__ARMCC_VERSION) &amp;&amp; (__ARMCC_VERSION &gt;&#x3D; 6010050)) https://blog.csdn.net/qq_44642831/article/details/116303460lwip.c lwip移植成功，电脑无法ping通原因是编译时未勾选 use microlib（具体原因不清楚）***********************************&#x2F; 6.26-6.28屏幕驱动移植ST7796屏幕一直无法点亮，使用逻辑分析仪查看SPI发送的数据正常，时序正常，使用的是野火电机开发板购买原厂底板准备测试 7.1原厂底板测试屏幕正常，使用逻辑分析仪看底板SPI数据和我的程序对应的数据一模一样屏幕接回自己的板子仍然点不亮，无疑按下复位，屏幕点亮（没有找到原因，板子重启，重新下载程序无法直接点亮屏幕且led线程工作正常，必须手动按一下复位按键才能点亮屏幕，简直玄学！！！）触摸驱动移植成功GT911 7.2跑台电机驱动协议分析使用逻辑分析仪监听跑台控制板向电机驱动发送的指令破解成功坡道角度控制，电机速度控制（最后找到商家，拿到了协议文档） 7.3lvgl移植成功屏幕刷新率3s一帧，SPI的速度为21M无法满足要求，更换并口屏幕测试 7.4-7.5使用H7测试并口屏 LTDC驱动移植成功 （遇到的问题：测试时屏幕显示又两层，只开启了一层导致显示被第二层覆盖，以为驱动移植存在问题） FFT变换同振幅多频率叠加时，频域图振幅错误 7.8-7.9足底压力传感器adc采样出现满偏情况，检查发现adc数据是int类型，不是满偏是-1 adc芯片使用MCP3914，差分输入，最高位为符号位 7.10足底PCB整合，和软件协调传感器点位 RGB屏幕验证成功，使用LTDC+DMA2D，使用SDRAM时存在问题，需要软件一直刷新，怀疑配置自动刷新存在问题","categories":[{"name":"工作日志","slug":"工作日志","permalink":"https://actorjing.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/"}],"tags":[]},{"title":"2024-2-15东至县城","slug":"2024-2-15东至县城","date":"2024-02-15T02:41:49.000Z","updated":"2024-07-05T16:06:46.839Z","comments":true,"path":"2024/02/15/2024-2-15东至县城/","link":"","permalink":"https://actorjing.github.io/2024/02/15/2024-2-15%E4%B8%9C%E8%87%B3%E5%8E%BF%E5%9F%8E/","excerpt":"","text":"","categories":[{"name":"摄影日记","slug":"摄影日记","permalink":"https://actorjing.github.io/categories/%E6%91%84%E5%BD%B1%E6%97%A5%E8%AE%B0/"}],"tags":[]},{"title":"嵌入式Linux6-UART串口","slug":"嵌入式Linux6-UART串口","date":"2024-02-06T15:09:33.000Z","updated":"2024-07-05T16:06:02.836Z","comments":true,"path":"2024/02/06/嵌入式Linux6-UART串口/","link":"","permalink":"https://actorjing.github.io/2024/02/06/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux6-UART%E4%B8%B2%E5%8F%A3/","excerpt":"","text":"UART串口 1、UART串口配置结构体struct termios { tcflag_t c_iflag; /* input mode flags */ tcflag_t c_oflag; /* output mode flags */ tcflag_t c_cflag; /* control mode flags */ tcflag_t c_lflag; /* local mode flags */ cc_t c_line; /* line discipline */ cc_t c_cc[NCCS]; /* control characters */ speed_t c_ispeed; /* input speed */ speed_t c_ospeed; /* output speed */ #define _HAVE_STRUCT_TERMIOS_C_ISPEED 1 #define _HAVE_STRUCT_TERMIOS_C_OSPEED 1 }; 串口属于一种终端设备，除此之外还包括常见的ssh等，它们都遵循终端统一的结构体termios，","categories":[{"name":"Linux嵌入式学习","slug":"Linux嵌入式学习","permalink":"https://actorjing.github.io/categories/Linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"Linux嵌入式5-FrameBuffer应用编程","slug":"Linux嵌入式5-FrameBuffer应用编程","date":"2024-01-31T03:49:08.000Z","updated":"2024-07-05T16:06:08.231Z","comments":true,"path":"2024/01/31/Linux嵌入式5-FrameBuffer应用编程/","link":"","permalink":"https://actorjing.github.io/2024/01/31/Linux%E5%B5%8C%E5%85%A5%E5%BC%8F5-FrameBuffer%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/","excerpt":"","text":"FrameBuffer应用编程1、内存映射用户程序操作文件的一般方式为调用系统库函数（open，read，write），库函数的流程为拷贝用户数据空间，到内核空间，获取文件句柄，返回用户空间，操作文件时，使用句柄到内核空间找到文件进行修改，每一次操作都是如此。用户空间和内核空间的机制导致数据传输速度不能最大，于是采用内存映射的方式。 用户程序可以直接访问内存，内存映射是在内存中申请空间对应物理文件，修改内存的数据会自动同步到物理文件，注意这个同步不是及时的，仍由内核调用，使用open这种库函数也不是及时同步，都是由内核调用同步，内存映射返回的是一个指针，可以直接访问和修改内容。 2、LCD应用编程流程 打开&#x2F;dev&#x2F;fdX设备文件 使用ioctl函数读取LCD参数信息 使用存储映射的方式将屏幕显示缓冲区映射到用户空间 直接读写显示缓冲区进行绘图和显示 完成显示后关闭存储映射，关闭设备文件 3、属性结构体介绍//显示设备的可变参数参数-一般表示显示屏显示大小，不变参数一般指硬件属性，比如缓冲区宽度 struct fb_var_screeninfo { __u32 xres; /* visible resolution */ __u32 yres; __u32 xres_virtual; /* virtual resolution */ __u32 yres_virtual; __u32 xoffset; /* offset from virtual to visible */ __u32 yoffset; /* resolution */ __u32 bits_per_pixel; /* guess what */ __u32 grayscale; /* 0 = color, 1 = grayscale, */ /* >1 = FOURCC */ struct fb_bitfield red; /* bitfield in fb mem if true color, */ struct fb_bitfield green; /* else only length is significant */ struct fb_bitfield blue; struct fb_bitfield transp; /* transparency */ __u32 nonstd; /* != 0 Non standard pixel format */ __u32 activate; /* see FB_ACTIVATE_* */ __u32 height; /* height of picture in mm */ __u32 width; /* width of picture in mm */ __u32 accel_flags; /* (OBSOLETE) see fb_info.flags */ /* Timing: All values in pixclocks, except pixclock (of course) */ __u32 pixclock; /* pixel clock in ps (pico seconds) */ __u32 left_margin; /* time from sync to picture */ __u32 right_margin; /* time from picture to sync */ __u32 upper_margin; /* time from sync to picture */ __u32 lower_margin; __u32 hsync_len; /* length of horizontal sync */ __u32 vsync_len; /* length of vertical sync */ __u32 sync; /* see FB_SYNC_* */ __u32 vmode; /* see FB_VMODE_* */ __u32 rotate; /* angle we rotate counter clockwise */ __u32 colorspace; /* colorspace for FOURCC-based modes */ __u32 reserved[4]; /* Reserved for future compatibility */ }; //显示设备的固定参数 struct fb_fix_screeninfo { char id[16]; /* identification string eg \"TT Builtin\" */ unsigned long smem_start; /* Start of frame buffer mem */ /* (physical address) */ __u32 smem_len; /* Length of frame buffer mem */ __u32 type; /* see FB_TYPE_* */ __u32 type_aux; /* Interleave for interleaved Planes */ __u32 visual; /* see FB_VISUAL_* */ __u16 xpanstep; /* zero if no hardware panning */ __u16 ypanstep; /* zero if no hardware panning */ __u16 ywrapstep; /* zero if no hardware ywrap */ __u32 line_length; /* length of a line in bytes */ unsigned long mmio_start; /* Start of Memory Mapped I/O */ /* (physical address) */ __u32 mmio_len; /* Length of Memory Mapped I/O */ __u32 accel; /* Indicate to driver which */ /* specific chip/card we have */ __u16 capabilities; /* see FB_CAP_* */ __u16 reserved[2]; /* Reserved for future compatibility */ }; //读取参数结构体 ioctl(fd, FBIOGET_VSCREENINFO, &amp;fb_var); ioctl(fd, FBIOGET_FSCREENINFO, &amp;fb_fix); 4、存储映射#include &lt;sys/mman.h> void *mmap (void *__addr, size_t __len, int __prot, int __flags, int __fd, __off_t __offset) __THROW;) //地址自动分配，传入NULL，在存储映射中遇到一个问题，显示屏的line_length和显示宽度width不一样，显示屏line_length由硬件缓冲区大小决定，申请内存时，空间大小应该为line_length*height，而不是width*height screen_base = mmap(NULL, screen_size, PROT_WRITE, MAP_SHARED, fd, 0); //关闭存储映射 munmap(screen_base, screen_size); 5、显示效果//颜色标准转换 #define argb8888_to_rgb565(color) ({ \\ unsigned int temp = (color);\\ ((temp &amp; 0xF80000UL) >> 8) | \\ ((temp &amp; 0xFC00UL) >> 5) | \\ ((temp &amp; 0xF8UL) >> 3); \\ }) 6、程序源码#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;sys/types.h> #include &lt;sys/stat.h> #include &lt;fcntl.h> #include &lt;unistd.h> #include &lt;string.h> #include &lt;poll.h> #include &lt;linux/input.h> #include &lt;sys/mman.h> #include &lt;linux/fb.h> #define argb8888_to_rgb565(color) ({ \\ unsigned int temp = (color);\\ ((temp &amp; 0xF80000UL) >> 8) | \\ ((temp &amp; 0xFC00UL) >> 5) | \\ ((temp &amp; 0xF8UL) >> 3); \\ }) static int width; static int height; static unsigned short *screen_base = NULL; // 打点 static void lcd_draw_point(unsigned int x, unsigned int y, unsigned int color){ unsigned short rgb565_color = argb8888_to_rgb565(color); if(x>=width) x = width-1; if(y>=height) y = height-1; screen_base[y*width +x] = rgb565_color; } // 画线 static void lcd_draw_line(unsigned int x, unsigned int y, int dir, unsigned int length, unsigned int color){ unsigned short rgb565_color = argb8888_to_rgb565(color); unsigned int end; unsigned long temp; if(x>=width) x = width-1; if(y>=height) y = height-1; temp = y*width +x; if (dir){ end = x + length -1; if(end>=width) end = width-1; for(; x&lt;=end; x++, temp++) screen_base[temp] = rgb565_color; } else{ end = y + length -1; if(end>=height) end = height-1; for(; y&lt;end; y++, temp+=width) screen_base[temp] = rgb565_color; } } // 画矩形 static void lcd_draw_rectangle(unsigned int start_x, unsigned int end_x, unsigned int start_y, unsigned int end_y, unsigned int color){ unsigned short rgb565_color = argb8888_to_rgb565(color); int x_len = end_x - start_x + 1; int y_len = end_y - start_y - 1; lcd_draw_line(start_x, start_y, 1, x_len, color); lcd_draw_line(start_x, end_y, 1, x_len, color); lcd_draw_line(start_x, start_y+1, 0, y_len, color); lcd_draw_line(end_x, start_y+1, 0, y_len, color); } //区域填充 static void lcd_fill(unsigned int start_x, unsigned int end_x, unsigned int start_y, unsigned int end_y, unsigned int color){ unsigned short rgb565_color = argb8888_to_rgb565(color); int x_len = end_x - start_x + 1; for(; start_y&lt;=end_y; start_y++) lcd_draw_line(start_x, start_y, 1, x_len, color); } int main(int argc, char *argv[]){ struct fb_fix_screeninfo fix_info; struct fb_var_screeninfo var_info; unsigned int screen_size; int fd; if (2 != argc) { fprintf(stderr,\"usage:%s &lt;event>\\n\", argv[0]); exit(-1); } if (0 > (fd = open(argv[1],O_RDWR))) { perror(\"open error\"); exit(-1); } if(0 > ioctl(fd, FBIOGET_VSCREENINFO, &amp;var_info)){ perror(\"ioctl error\"); exit(-1); } if(0 > ioctl(fd, FBIOGET_FSCREENINFO, &amp;fix_info)){ perror(\"ioctl error\"); exit(-1); } screen_size = fix_info.line_length * var_info.yres; width = var_info.xres; height = var_info.yres; printf(\"frame config x:%d, y:%d\\n\", var_info.xres, var_info.yres); printf(\"frame config size:%d\\n\", fix_info.line_length); screen_base = mmap(NULL, screen_size, PROT_WRITE, MAP_SHARED, fd, 0); if(MAP_FAILED == (void *)screen_base){ perror(\"mmap error\"); close(fd); exit(EXIT_FAILURE); } /* 画正方形方块 */ int w = height * 0.25;//方块的宽度为 1/4 屏幕高度 lcd_fill(0, width-1, 0, height-1, 0x0); //清屏（屏幕显示黑色） lcd_fill(0, w, 0, w, 0xFF0000); //红色方块 lcd_fill(width-w, width-1, 0, w, 0xFF00); //绿色方块 lcd_fill(0, w, height-w, height-1, 0xFF); //蓝色方块 lcd_fill(width-w, width-1, height-w, height-1, 0xFFFF00);//黄色方块 /* 画线: 十字交叉线 */ lcd_draw_line(0, height * 0.5, 1, width, 0xFFFFFF);//白色线 lcd_draw_line(width * 0.5, 0, 0, height, 0xFFFFFF);//白色线 /* 画矩形 */ unsigned int s_x, s_y, e_x, e_y; s_x = 0.25 * width; s_y = w; e_x = width - s_x; e_y = height - s_y; for ( ; (s_x &lt;= e_x) &amp;&amp; (s_y &lt;= e_y); s_x+=5, s_y+=5, e_x-=5, e_y-=5) lcd_draw_rectangle(s_x, e_x, s_y, e_y, 0xFFFFFF); printf(\"frame draw over1\\n\"); munmap(screen_base, screen_size); close(fd); exit(0); }","categories":[{"name":"Linux嵌入式学习","slug":"Linux嵌入式学习","permalink":"https://actorjing.github.io/categories/Linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"2024-1-25红星路互勉","slug":"2024-1-25红星路互勉","date":"2024-01-29T07:21:49.000Z","updated":"2024-07-05T16:06:52.350Z","comments":true,"path":"2024/01/29/2024-1-25红星路互勉/","link":"","permalink":"https://actorjing.github.io/2024/01/29/2024-1-25%E7%BA%A2%E6%98%9F%E8%B7%AF%E4%BA%92%E5%8B%89/","excerpt":"","text":"2024.1.25记录第一次互勉约拍，地点在红星路，路人阿姨说小姐姐坐在那像幅画一样","categories":[{"name":"摄影日记","slug":"摄影日记","permalink":"https://actorjing.github.io/categories/%E6%91%84%E5%BD%B1%E6%97%A5%E8%AE%B0/"}],"tags":[]},{"title":"2024-1-21城隍庙","slug":"2024-1-21城隍庙","date":"2024-01-21T14:34:44.000Z","updated":"2024-07-05T16:06:57.211Z","comments":true,"path":"2024/01/21/2024-1-21城隍庙/","link":"","permalink":"https://actorjing.github.io/2024/01/21/2024-1-21%E5%9F%8E%E9%9A%8D%E5%BA%99/","excerpt":"","text":"城隍庙左咪咪右修勾","categories":[{"name":"摄影日记","slug":"摄影日记","permalink":"https://actorjing.github.io/categories/%E6%91%84%E5%BD%B1%E6%97%A5%E8%AE%B0/"}],"tags":[]},{"title":"FOC硬件日记（正在更新）","slug":"FOC硬件日记","date":"2024-01-20T15:33:48.000Z","updated":"2024-07-05T16:06:37.296Z","comments":true,"path":"2024/01/20/FOC硬件日记/","link":"","permalink":"https://actorjing.github.io/2024/01/20/FOC%E7%A1%AC%E4%BB%B6%E6%97%A5%E8%AE%B0/","excerpt":"","text":"1.20硬件设计，参考STC的无感BLDC方案，但是主控更换为STM32，三相逆变器采用FD6288Q，使用mos桥方式支持大电流（考虑小电流drv8313方案，只支持2A电流，仍然需要加mos驱动，考虑成本选择FD6288Q）。考虑加入电流环，电流检测采用INA199A1DCKR。下图为三相逆变电路及电流检测： 存在验证的问题： 问题1：FD6288官方手册外围电路中需要增加自举电阻，参考开源方案并没有加入自举电阻， 问题2：电流检测放在半桥的下桥接地，理论上放在哪儿无影响 问题3：电流检测压差采用分压电阻得到1.65V，参考STM32F103C的FOC方案设计，C系列无VREF 单片机选型使用STM32F103ZET6（理论上做6路FOC电机都没问题，大炮打蚊子），最初选型考虑STM32G和STM32F4系列，最终由于价格和学习基础理论，采用ZET6（主要因为手头有剩的）。单片机VREF采用3.3V，可能会出现精度问题，暂不考虑。电源设计如下： 电路中5V仅作为FD6288Q芯片供电，为了电路简单，使用AMS1117（手头有剩的），MCU和其他电路的3.3V区分，分别使用两个RT9013稳压。完整电路还包括显示，串口，交互按键，暂未完成。 1.22参考柠檬FOC项目，又看到开源博主说FD6288的最低供电为12V，但是看芯片手册输入电压为4~24V，原STC无感电路设计采用5V，电机高速长时间运行时，ams1117处于温热状态，考虑更换为buck电路： FD6288Q仍然使用5V供电。 1.24完成原理图设计和PCB大致布局，完善USB串口，交互按键和LED指示灯。完整原理图如下： 电机接口考虑使用铜皮开窗，使用香蕉头和电机连接，或直接焊接。","categories":[{"name":"FOC学习","slug":"FOC学习","permalink":"https://actorjing.github.io/categories/FOC%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"Linux嵌入式4-tslib库函数","slug":"Linux嵌入式4-tslib库函数","date":"2024-01-18T13:53:01.000Z","updated":"2024-07-05T16:06:17.708Z","comments":true,"path":"2024/01/18/Linux嵌入式4-tslib库函数/","link":"","permalink":"https://actorjing.github.io/2024/01/18/Linux%E5%B5%8C%E5%85%A5%E5%BC%8F4-tslib%E5%BA%93%E5%87%BD%E6%95%B0/","excerpt":"","text":"1、tslib简介 tslib是为触摸屏设备开发的linux应用层库函数，通过配置conf文件适配触摸屏信息，通过调用函数得到触摸屏的实时触摸点信息。tslib移植过程参考应用开发编程指南第18章。 2、tslib库函数介绍配置、打开触摸屏设备函数： #include \"tslib.h\" /* dev_name: 设备节点 nonblock： 0为阻塞方法打开触摸屏设备，非0表示非阻塞 */ struct tsdev *ts_open(const char *dev_name, int nonblock); /* 参数与上面相同，区别是，dev_name可以设置为NULL，函数会在配置文件读取设备节点 */ struct tsdev *ts_setup(const char *dev_name, int nonblock) //关闭触摸屏设备 int ts_close(struct tsdev *); //配置触摸屏设备 int ts_config(struct tsdev *ts) //获取触摸屏事件句柄 ts_fd(ts) 读取触摸屏数据函数： /* */ int ts_read(struct tsdev *ts, struct ts_sample *samp, int nr) /* */ int ts_read_mt(struct tsdev *ts, struct ts_sample_mt **samp, int max_slots, int nr) 3、tslib多点触摸测试：tslib流程： 1、配置触摸屏 ts = ts_setup(NULL,0); 2、读取触摸屏信息，计算最大触摸点数，申请触摸点信息数组 if(0 > ioctl(ts_fd(ts), EVIOCGABS(ABS_MT_SLOT), &amp;info)){ perror(\"ioctl error\"); exit(-1); } //获取最大触摸点 max_slots = info.maximum + 1 - info.minimum; printf(\"max slots: %d\\n\",max_slots); //申请存储触摸点数组空间 samp = calloc(max_slots, sizeof(struct ts_sample_mt)); 3、读取触摸屏数据 //读触摸屏数据 if(0>ts_read_mt(ts, &amp;samp, max_slots, 1)){ perror(\"ts_read error\"); ts_close(ts); exit(-1); } 4、解算触摸屏坐标 #include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;sys/types.h> #include &lt;sys/stat.h> #include &lt;fcntl.h> #include &lt;unistd.h> #include &lt;string.h> #include &lt;poll.h> #include &lt;linux/input.h> #include &lt;tslib.h> // 多点触摸实验 // /dev/input/event1 int main(int argc, char *argv[]){ //tsdev是设备文件 tslib struct tsdev *ts = NULL; //sample是具体坐标信息 struct ts_sample_mt *samp = NULL; struct input_absinfo info; struct ts_mt *mt = NULL; int max_slots; int pressure[12] = {0}; //配置触摸屏 ts = ts_setup(NULL,0); if(NULL==ts){ perror(\"ts_setup error\"); exit(-1); } //ts_fd获取触摸屏事件句柄，再获取触摸屏信息 if(0 > ioctl(ts_fd(ts), EVIOCGABS(ABS_MT_SLOT), &amp;info)){ perror(\"ioctl error\"); exit(-1); } //获取最大触摸点 max_slots = info.maximum + 1 - info.minimum; printf(\"max slots: %d\\n\",max_slots); //申请存储触摸点数组空间 samp = calloc(max_slots, sizeof(struct ts_sample_mt)); for (;;) { //读触摸屏数据 if(0>ts_read_mt(ts, &amp;samp, max_slots, 1)){ perror(\"ts_read error\"); ts_close(ts); exit(-1); } for (size_t i = 0; i &lt; max_slots; i++) { //触摸点状态发生改变 if(samp[i].valid) { //判断压力是否大于0 是表示按下 否表示松开 if (samp[i].pressure) { //上一次压力为0表示刚按下 否则表示移动 if(pressure[samp[i].slot]==0){ printf(\"%d按下：x=%d y=%d\\n\", samp[i].slot, samp[i].x, samp[i].y); } else{ printf(\"%d移动：x=%d y=%d\\n\", samp[i].slot, samp[i].x, samp[i].y); } } else{ printf(\"%d松开\\n\", samp[i].slot); } } //更新历史压力 pressure[samp[i].slot] = samp[i].pressure; } } ts_close(ts); free(samp); exit(0); }","categories":[{"name":"Linux嵌入式学习","slug":"Linux嵌入式学习","permalink":"https://actorjing.github.io/categories/Linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"虫子移动问题","slug":"虫子移动问题","date":"2024-01-16T13:41:05.000Z","updated":"2024-07-05T16:05:53.616Z","comments":true,"path":"2024/01/16/虫子移动问题/","link":"","permalink":"https://actorjing.github.io/2024/01/16/%E8%99%AB%E5%AD%90%E7%A7%BB%E5%8A%A8%E9%97%AE%E9%A2%98/","excerpt":"","text":"虫子移动问题1、问题描述：存在一个5行12列的表格，第一列有5只虫子，编号1，2，3，4，5；每只虫子的移动方向只能是向右、右上方、右下方三种方向；5只虫子进行移动操作后到达第二列，要求每一行都存在一只虫子，同样的要求，五只虫子要到达第12列，虫子每次移动操作对应着不同的权重矩阵相加，虫子从第1列到达第12列的过程存在很多种权重矩阵和，找出权重矩阵方差最小的路线。问题简化如下： 简化：存在一个5*12的表格，第一列为15，每个数可以进行-1，不变，+1的操作，进入到下一列，要求进入到下一列的五个数范围还在15，且不能重复，每次操作对应不同的权重矩阵，求到第12列时，权重矩阵方差最小的移动方案。 2、求解思路：已知15个数字任意组合一共有5！（120）种方案，通过暴力破解验证得到每种组合按照题目要求移动一列都存在8种情况，这样可以知道一共有120*8种生成子集，可以通过查表法省去迭代的时间。先建立一个列表，一维空间为10000，查表下标计算为六进制，考虑一共有5个数，数字范围在15且不重复，使用六进制可以间接的描述出表的下标，存在的缺陷就是造成空间浪费，实际只有120个下标用到，二维空间为对应的8种情况序列。建表过程为： numbers = [1, 2, 3, 4, 5] # 列出所有排列 permutations = list(itertools.permutations(numbers)) # 对每个排列进行操作，并计算结果 results = set() for perm in permutations: result = sum([perm[i] * (6**(4-i)) for i in range(5)]) results.add(result) from itertools import product operations = [-1, 0, 1] initial_case = [1, 2, 3, 4, 5] initial_operations = list(product(operations, repeat=len(initial_case))) # 暴力破解得到每种情况移动后的子情况 def getdata(initial_case ): valid_initial_cases = [] for ops in initial_operations: new_numbers = [n + op for n, op in zip(initial_case, ops)] if len(set(new_numbers)) == len(new_numbers) and all(1 &lt;= num &lt;= 5 for num in new_numbers): valid_initial_cases.append(new_numbers) return valid_initial_cases table = [0]*10000 for perm in permutations: table[sum([perm[i] * (6**(4-i)) for i in range(5)])] = getdata(perm) 这样在每次移动时只需要通过查表法得到子情况集，不需要再进行迭代求解，节约一定时间。建立查表法生成树结构来描述所有情况，在叶子节点可以求解当前路径的权重矩阵方差，记录最小的权重矩阵的值和移动路径。 3、运行结果：构建深度为12的树，且每个节点存在8个子节点，尽管使用查表法省去一定的时间，但是庞大的基数仍然时问题无法求解，最后优化下求解出深度为8时的最优路径： 耗时3分钟，往后每增加一层，时间增加8倍，理论求解出12层的时间为8天，于是果断放弃！ 4、程序源码：import itertools import pickle from copy import deepcopy import time import numpy as np import itertools numbers = [1, 2, 3, 4, 5] # 列出所有排列 permutations = list(itertools.permutations(numbers)) # 对每个排列进行操作，并计算结果 results = set() for perm in permutations: result = sum([perm[i] * (6**(4-i)) for i in range(5)]) results.add(result) from itertools import product operations = [-1, 0, 1] initial_case = [1, 2, 3, 4, 5] initial_operations = list(product(operations, repeat=len(initial_case))) def getdata(initial_case ): valid_initial_cases = [] for ops in initial_operations: new_numbers = [n + op for n, op in zip(initial_case, ops)] if len(set(new_numbers)) == len(new_numbers) and all(1 &lt;= num &lt;= 5 for num in new_numbers): valid_initial_cases.append(new_numbers) return valid_initial_cases table = [0]*10000 for perm in permutations: table[sum([perm[i] * (6**(4-i)) for i in range(5)])] = getdata(perm) initial_case = [1,2,3,4,5] # print(table[sum([initial_case[i] * (6**(4-i)) for i in range(5)])]) with open(\"my_list.pkl\", \"wb\") as file: pickle.dump(table, file) class TreeNode: def __init__(self, value): self.value = deepcopy(value) self.children = [] # 创建树 root = TreeNode(1) # root.value.append(initial_case) root.value = [initial_case] def getNode(initial_case, Node): for numbers in iter(table[sum([initial_case[i] * (6 ** (4 - i)) for i in range(5)])]): Node.children.append(TreeNode(numbers)) return Node.children start_time = time.time() dataa = np.load('../../../../../../Documents/WeChat Files/wxid_fm5zrvq5j2an22/FileStorage/File/2024-01/value.npy') minfangcha = 100000000 print(dataa.shape) save_result = [] # for nums in root.value: Tree = getNode(root.value[0], root) #----------------第二维度 for children1 in Tree: Tree1 = getNode(children1.value, children1) #----------------第三维度 for children2 in Tree1: Tree2 = getNode(children2.value, children2) #----------------第四维度 for children3 in Tree2: Tree3 = getNode(children3.value, children3) #----------------第五维度 for children4 in Tree3: Tree4 = getNode(children4.value, children4) #----------------第六维度 for children5 in Tree4: Tree5 = getNode(children5.value, children5) #----------------第七维度 for children6 in Tree5: Tree6 = getNode(children6.value, children6) for children7 in Tree6: result = [] indices = [root.value[0].index(num) for num in range(1, 6)] result.append(indices) indices = [children1.value.index(num) for num in range(1, 6)] result.append(indices) indices = [children2.value.index(num) for num in range(1, 6)] result.append(indices) indices = [children3.value.index(num) for num in range(1, 6)] result.append(indices) indices = [children4.value.index(num) for num in range(1, 6)] result.append(indices) indices = [children5.value.index(num) for num in range(1, 6)] result.append(indices) indices = [children6.value.index(num) for num in range(1, 6)] result.append(indices) indices = [children7.value.index(num) for num in range(1, 6)] result.append(indices) result = list(map(list, zip(*result))) bianliang1 = dataa[result[0][0]][0] + dataa[result[0][1]][1] + dataa[result[0][2]][2] + \\ dataa[result[0][3]][3] + dataa[result[0][4]][4] + dataa[result[0][5]][5] + \\ dataa[result[0][6]][6] + dataa[result[0][7]][7] bianliang2 = dataa[result[1][0]][0] + dataa[result[1][1]][1] + dataa[result[1][2]][2] + \\ dataa[result[1][3]][3] + dataa[result[1][4]][4] + dataa[result[1][5]][5] + \\ dataa[result[1][6]][6] + dataa[result[1][7]][7] bianliang3 = dataa[result[2][0]][0] + dataa[result[2][1]][1] + dataa[result[2][2]][2] + \\ dataa[result[2][3]][3] + dataa[result[2][4]][4] + dataa[result[2][5]][5] + \\ dataa[result[2][6]][6] + dataa[result[2][7]][7] bianliang4 = dataa[result[3][0]][0] + dataa[result[3][1]][1] + dataa[result[3][2]][2] + \\ dataa[result[3][3]][3] + dataa[result[3][4]][4] + dataa[result[3][5]][5] + \\ dataa[result[3][6]][6] + dataa[result[3][7]][7] bianliang5 = dataa[result[4][0]][0] + dataa[result[4][1]][1] + dataa[result[4][2]][2] + \\ dataa[result[4][3]][3] + dataa[result[4][4]][4] + dataa[result[4][5]][5] + \\ dataa[result[4][6]][6] + dataa[result[4][7]][7] bianliang = (bianliang1 + bianliang2 + bianliang3 + bianliang4 + bianliang5) / 5 fangcha = np.sum((bianliang - bianliang1)**2) + np.sum((bianliang - bianliang2)**2) + \\ np.sum((bianliang - bianliang3)**2) + np.sum((bianliang - bianliang4)**2) + \\ np.sum((bianliang - bianliang5)**2) if fangcha &lt; minfangcha: minfangcha = fangcha save_result = result # 记录结束时间 end_time = time.time() # 计算执行时间 execution_time = end_time - start_time # 打印执行时间 print(f\"程序执行时间: {execution_time} 秒\") print(minfangcha) print(save_result) # for nums in root.children: # print(nums.value)","categories":[{"name":"算法","slug":"算法","permalink":"https://actorjing.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"Linux嵌入式3-输入设备","slug":"Linux嵌入式3-输入设备","date":"2024-01-14T11:04:22.000Z","updated":"2024-07-05T16:06:22.690Z","comments":true,"path":"2024/01/14/Linux嵌入式3-输入设备/","link":"","permalink":"https://actorjing.github.io/2024/01/14/Linux%E5%B5%8C%E5%85%A5%E5%BC%8F3-%E8%BE%93%E5%85%A5%E8%AE%BE%E5%A4%87/","excerpt":"","text":"1、输入类设备描述设备文件路径：&#x2F;dev&#x2F;input&#x2F;event 查看设备事件命令：cat &#x2F;proc&#x2F;bus&#x2F;input&#x2F;devices 2、linux内核描述输入设备描述事件查看事件描述符在”input-event-codes.h“文件中，已经在linux&#x2F;input.h中包含 struct input_event { #if (__BITS_PER_LONG != 32 || !defined(__USE_TIME_BITS64)) &amp;&amp; !defined(__KERNEL__) struct timeval time; #define input_event_sec time.tv_sec #define input_event_usec time.tv_usec #else __kernel_ulong_t __sec; #if defined(__sparc__) &amp;&amp; defined(__arch64__) unsigned int __usec; unsigned int __pad; #else __kernel_ulong_t __usec; #endif #define input_event_sec __sec #define input_event_usec __usec #endif __u16 type; __u16 code; __s32 value; }; /* timeval 为事件上报时间 type 为事件类型 code 为具体事件 value 为事件的值 例如键盘按键KEY0按下时，type表示触发按键，code表示KEY0，value表示按下还是松开 */ 数据同步： 同步事件EV_SYN用于实现同步操作、告知接收者本轮上报的数据已经完整，例如触摸屏幕一次操作需要上报x轴坐标，y轴坐标、触摸点信息等，此时就需要同步事件。同步事件的type类型如下： #define SYN_REPORT 0 #define SYN_CONFIG 1 #define SYN_MT_REPORT 2 #define SYN_DROPPED 3 #define SYN_MAX 0xf #define SYN_CNT (SYN_MAX+1) 所有的事件上报完成后都需要再上报一个同步事件，一般是SYN_REPORT，value为0。 3、读取开发板上报事件#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;sys/types.h> #include &lt;sys/stat.h> #include &lt;fcntl.h> #include &lt;unistd.h> #include &lt;string.h> #include &lt;poll.h> #include &lt;linux/input.h> // /dev/input/event2 int main(int argc, char *argv[]){ char gpio_path[100]; char file_path[100]; struct input_event in_ev = {0}; struct pollfd pfd; char val; int fd; //效验传参 ./exe /dev/input/event2 if (2 != argc) { fprintf(stderr,\"usage:%s &lt;gpio> &lt;value>\\n\", argv[0]); exit(-1); } //打开事件 if (0 > (fd = open(argv[1],O_RDONLY))) { perror(\"open export error\"); exit(-1); } //循环阻塞时读取上报事件 for (;;) { /* code */ if (sizeof(struct input_event) != read(fd, &amp;in_ev, sizeof(struct input_event))) { /* code */ perror(\"read error!\"); exit(-1); } printf(\"type: %d code: %d value: %d\\n\",in_ev.type, in_ev.code, in_ev.value); } exit(0); } 4、触摸屏上报事件分析 按下触摸屏后触发绝对位移事件EV_ABS（type&#x3D;3）中的ABS_MT_TRACKING_ID（code&#x3D;57）事件，value为78，表示有一个新的触点被创建，value为-1时表示触点松开，触点的ID为78，53和54分别表示x坐标和y坐标。 获取触摸屏信息 需要使用一个开放函数：ioctl（input&#x2F;output control） int ioctl(int fd, unsigned long request, ...); /* fd 是文件描述符，表示要控制的设备。 request 是控制命令，通常是一个宏，定义了要执行的特定操作。 可选的参数 ... 取决于特定的 ioctl 命令，可能包含输入参数、输出参数或者不需要参数。 */ //查询触摸屏触点信息，存放在info中 struct input_absinfo info; if(0 > ioctl(fd, EVIOCGABS(ABS_MT_SLOT), &amp;info)){ perror(\"ioctl error\"); exit(-1); } /* 常用来处理陀螺仪数据 struct input_absinfo { __s32 value; __s32 minimum; __s32 maximum; __s32 fuzz; __s32 flat; __s32 resolution; }; */ 获取触摸点程序源码： #include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;sys/types.h> #include &lt;sys/stat.h> #include &lt;fcntl.h> #include &lt;unistd.h> #include &lt;string.h> #include &lt;poll.h> #include &lt;linux/input.h> // /dev/input/event2 int main(int argc, char *argv[]){ char gpio_path[100]; char file_path[100]; struct input_absinfo info; struct pollfd pfd; int max_slots; int fd; if (2 != argc) { fprintf(stderr,\"usage:%s &lt;gpio> &lt;value>\\n\", argv[0]); exit(-1); } if (0 > (fd = open(argv[1],O_RDONLY))) { perror(\"open export error\"); exit(-1); } if(0 > ioctl(fd, EVIOCGABS(ABS_MT_SLOT), &amp;info)){ perror(\"ioctl error\"); exit(-1); } max_slots = info.maximum - info.minimum; printf(\"max slots: %d\\n\",max_slots); exit(0); } 5、单点触摸测试参考多点触摸实验 6、多点触摸测试多点实验中，触摸点信息上报流程： 第一个触摸点直接上报ABS_MT_TRACKING_ID，ID只需知道是否为0，-1，大于0即可，具体编号不需要关心 出现第二个触摸点时，先上报ABS_MT_SLOT槽位信息，再上报坐标信息，最后上报ABS_MT_TRACKING_ID 如果另一个触摸点发生移动时，先上传ABS_MT_SLOT，再上传坐标信息，相同触摸点移动不上报ABS_MT_SLOT #include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;sys/types.h> #include &lt;sys/stat.h> #include &lt;fcntl.h> #include &lt;unistd.h> #include &lt;string.h> #include &lt;poll.h> #include &lt;linux/input.h> // 多点触摸实验 // /dev/input/event1 //每个触摸点信息，valid为1时表示触摸点状态更新 struct ts_mt { int x; int y; int id; // 表示触摸屏的唯一ID ABS_MT_TRACKING_ID int valid; }; //缓存记录坐标，等待上报同步事件后再将坐标写在ts_mt结构体数组返回 struct tp_xy { int x; int y; }; /* 读取一次同步事件的触摸点坐标 fd: 时间句柄 max_slots： 最大触摸点数 mt: ts_mt数组指针 */ static int ts_read(const int fd, const int max_slots, struct ts_mt *mt) { //上报事件 struct input_event in_ev; static int slot = 0; static struct tp_xy xy[12] = {0}; int i; //清空ts_mt数组指针内容 memset(mt, 0x0, max_slots*sizeof(struct ts_mt)); // 设置id为-2，不为0表示触摸点按下，-1表示触摸点松开 for (i = 0; i &lt; max_slots; i++) mt[i].id = -2; for (;;) { if(sizeof(struct input_event) != read(fd, &amp;in_ev, sizeof(struct input_event))){ perror(\"read error\"); return -1; } switch (in_ev.type) { // 判断绝对位移事件 case EV_ABS: switch (in_ev.code) { // 触摸点槽位 code=47 case ABS_MT_SLOT: slot = in_ev.value; break; // X轴坐标 code=53 case ABS_MT_POSITION_X: xy[slot].x = in_ev.value; mt[slot].valid = 1; break; // y轴坐标 code=54 case ABS_MT_POSITION_Y: xy[slot].y = in_ev.value; mt[slot].valid = 1; break; // 触摸点ID code=57 等于0表示移动事件 case ABS_MT_TRACKING_ID: mt[slot].id = in_ev.value; mt[slot].valid = 1; break; } break; // 判断同步事件 case EV_SYN: if(SYN_REPORT==in_ev.code){ //将记录的坐标更新到mt中 for (size_t i = 0; i &lt; max_slots; i++) { mt[i].x = xy[i].x; mt[i].y = xy[i].y; } } return 0; } } } int main(int argc, char *argv[]){ char gpio_path[100]; char file_path[100]; struct input_absinfo info; struct ts_mt *mt = NULL; struct pollfd pfd; int max_slots; int fd; if (2 != argc) { fprintf(stderr,\"usage:%s &lt;gpio> &lt;value>\\n\", argv[0]); exit(-1); } if (0 > (fd = open(argv[1],O_RDONLY))) { perror(\"open export error\"); exit(-1); } if(0 > ioctl(fd, EVIOCGABS(ABS_MT_SLOT), &amp;info)){ perror(\"ioctl error\"); exit(-1); } max_slots = info.maximum + 1 - info.minimum; printf(\"max slots: %d\\n\",max_slots); //创建长度为max_slots的触摸点信息数组 mt = calloc(max_slots, sizeof(struct ts_mt)); for (; ; ) { if(0>ts_read(fd, max_slots, mt)) break; for (size_t i = 0; i &lt; max_slots; i++) { //判断第i个触摸点的状态是否发生改变 if (mt[i].valid) { if (0&lt;=mt[i].id) printf(\"slot&lt;%d>, 按下(%d, %d)\\n\", i, mt[i].x, mt[i].y); else if(-1==mt[i].id) printf(\"slot&lt;%d>, 松开\\n\", i); else printf(\"slot&lt;%d>, 移动(%d, %d)\\n\", i, mt[i].x, mt[i].y); } } } close(fd); free(mt); exit(EXIT_FAILURE); exit(0); }","categories":[{"name":"Linux嵌入式学习","slug":"Linux嵌入式学习","permalink":"https://actorjing.github.io/categories/Linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"Linux嵌入式2-GPIO编程","slug":"Linux嵌入式2-GPIO编程","date":"2024-01-14T04:42:33.000Z","updated":"2024-07-05T16:06:27.652Z","comments":true,"path":"2024/01/14/Linux嵌入式2-GPIO编程/","link":"","permalink":"https://actorjing.github.io/2024/01/14/Linux%E5%B5%8C%E5%85%A5%E5%BC%8F2-GPIO%E7%BC%96%E7%A8%8B/","excerpt":"","text":"头文件说明&lt;sys/types.h>：该头文件定义了一些基本的系统数据类型，如size_t、time_t等。 &lt;sys/stat.h>：该头文件定义了一些关于文件状态的函数和宏，如stat()、S_IRUSR等。 &lt;fcntl.h>：该头文件定义了一些文件控制操作的函数和常量，如open()、O_RDONLY等。 &lt;unistd.h>：该头文件定义了一些系统调用函数，如read()、write()等。 函数说明int access(const char *pathname, int mode); /* mode 是要检查的权限模式。常用的权限模式有以下几种： F_OK：用于检查文件或目录是否存在。 R_OK：用于检查文件或目录是否可读。 W_OK：用于检查文件或目录是否可写。 X_OK：用于检查文件或目录是否可执行。 存在返回0，不存在返回-1 */ len = strlen(argv[1]); if(len != write(fd,argv[1],len)){ } /* write函数向文件写入数据，写入argv[1]字符串，后面接写入的字节数，成功返回写入的字节数 */ 一、GPIO应用编程1、基础属性：gpio设备目录在&#x2F;sys&#x2F;class&#x2F;gpio中： gpiochip0128分别对应i.max6ull的五组gpio15，export用来导出指定编号的gpio，加入需要导出GPIO4_IO20，首先需要确定GPIO的编号，GPIO4对应gpiochip96，编号为94+20&#x3D;114 执行导出命令为echo 94 &gt; export 以导出GPIO0_IO1为例：执行echo 1 &gt; export，会生成一个gpio1的文件夹，里面描述了gpio1的相关信息： dirction: IO的方向可以设置为out 和 in active_low: 电平逻辑状态，默认为0，此时1为高电平 0为低电平 value： 电平状态 edge: 中断触发：none rising falling both分别表示无触发、上升沿、下降沿、边沿触发 2、gpio_config函数/* path：gpioX路径 /sys/class/gpio/gpio1 attr：需要修改的属性 direction value：修改的具体值 out */ int gpio_config(const char *path, const char *attr, const char *val){ int fd; int len; char file_path[100]; // 拼接字符串 sprintf(file_path,\"%s/%s\", path, attr); // 打开文件 if (0 > (fd = open(file_path, O_WRONLY))) { perror(\"open gpio error\"); close(fd); return -1; } // 向文件写入指定长度的数据 len = strlen(val); if (len != write(fd, val, len)) { perror(\"write info error\"); close(fd); return -1; } close(fd); fprintf(stderr,\"write success!\\n\"); return 0; } // main函数： // 判断输入的gpioX是否存在，不存在需要通过写export文件导出IO sprintf(gpio_path,\"/sys/class/gpio/gpio%s\",argv[1]); if (access(gpio_path,F_OK)) { int fd; int len; if (0 > (fd = open(\"/sys/class/gpio/export\",O_WRONLY))) { perror(\"open export error\"); exit(-1); } len = strlen(argv[1]); if(len != write(fd,argv[1],len)){ perror(\"write error\"); close(fd); exit(-1); } close(fd); } if(gpio_config(gpio_path,\"direction\", \"in\")){ fprintf(stderr,\"write direction error\\n\"); exit(-1); } if(gpio_config(gpio_path,\"active_low\", \"0\")){ fprintf(stderr,\"write active_low error\\n\"); exit(-1); } if(gpio_config(gpio_path,\"value\", argv[2])){ fprintf(stderr,\"write value error\\n\"); exit(-1); } 3、poll()函数// 使用poll()函数实现非阻塞式中断触发 int main(int argc, char *argv[]){ char gpio_path[100]; char file_path[100]; // 创建pollfd结构体，描述文件就绪状态 struct pollfd pfd; char val; int ret; if (2 != argc) { fprintf(stderr,\"usage:%s &lt;gpio> &lt;value>\\n\", argv[0]); exit(-1); } sprintf(gpio_path,\"/sys/class/gpio/gpio%s\",argv[1]); if (access(gpio_path,F_OK)) { int fd; int len; if (0 > (fd = open(\"/sys/class/gpio/export\",O_WRONLY))) { perror(\"open export error\"); exit(-1); } len = strlen(argv[1]); if(len != write(fd,argv[1],len)){ perror(\"write error\"); close(fd); exit(-1); } close(fd); } if(gpio_config(gpio_path,\"direction\", \"in\")){ fprintf(stderr,\"write direction error\\n\"); exit(-1); } if(gpio_config(gpio_path,\"active_low\", \"0\")){ fprintf(stderr,\"write active_low error\\n\"); exit(-1); } // 配置为边沿触发 if(gpio_config(gpio_path,\"edge\", \"both\")){ fprintf(stderr,\"write edge error\\n\"); exit(-1); } // 打开IO状态value文件，文件描述符保存在pfd.fd sprintf(file_path,\"%s/%s\", gpio_path, \"value\"); if (0 > (pfd.fd = open(file_path,O_RDONLY))) { perror(\"open pfd.fd error\"); exit(-1); } pfd.events = POLLPRI;// 只关心高优先级数据可读 中断 只有高优先级才会触发文件转换为就绪态 read(pfd.fd, &amp;val, 1);// 读取一次清除状态 //轮询读取 for (;;) { // 监听pfd文件状态，内部有一个文件描述符 超时时间-1 ret = poll(&amp;pfd, 1, -1); if (0 > ret) { perror(\"poll error\"); exit(-1); } else if(0 == ret){ fprintf(stderr,\"poll time out\"); exit(-1); } // 事件触发 if (pfd.revents &amp; POLLPRI) { // 因为之前读取过文件，需要移动指针到0 if(0 > lseek(pfd.fd, 0, SEEK_SET)){ perror(\"lseek error\"); exit(-1); } // 读取文件 if (0 > read(pfd.fd, &amp;val, 1)) { perror(\"read pfd.fd error\"); exit(-1); } printf(\"get interupt &lt;value=%c>\\n\", val); } } exit(0); }","categories":[{"name":"Linux嵌入式学习","slug":"Linux嵌入式学习","permalink":"https://actorjing.github.io/categories/Linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"Linux嵌入式1-启动开发环境","slug":"Linux嵌入式1-基础知识","date":"2024-01-14T03:16:38.000Z","updated":"2024-07-05T16:06:32.610Z","comments":true,"path":"2024/01/14/Linux嵌入式1-基础知识/","link":"","permalink":"https://actorjing.github.io/2024/01/14/Linux%E5%B5%8C%E5%85%A5%E5%BC%8F1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"应用开发环境搭建：开发板移植uboot：完成网络移植 服务器安装nfs和tftp windows、服务器、开发板需要处在同一网段，使用虚拟需要添加网卡开启桥接模式，关闭防火墙 挂载zImage和dtb之前先使用nfs和tftp测试 完成配置后 uboot在emmc中，zImage和dtb使用tftp挂载，根文件系统使用nfs挂载 最后验证交叉编译工具 安装nfs过程出现的问题，挂载失败，检查是服务器nfs版本为4，uboot只支持2（原文链接：https://blog.csdn.net/qq_42212668/article/details/125250873） 配置过程中的常用命令：setenv ipaddr 192.168.1.50 setenv ethaddr b8:ae:1d:01:00:00 setenv gatewayip 192.168.1.1 setenv netmask 255.255.255.0 setenv serverip 192.168.1.253 saveenv nfs启动文件系统： setenv bootargs 'console=ttymxc0,115200 root=/dev/nfs nfsroot=192.168.1.107:/home/wujing/linux/nfs/alientrootfs,proto=tcp rw ip=192.168.1.50:192.168.1.107:192.168.1.1:255.255.255.0::eth0:off' tftp挂载 setenv bootcmd 'tftp 80800000 zImage; tftp 83000000 imx6ull-14x14-emmc-4.3-800x480-c.dtb; bootz 80800000 - 83000000' 应用开发环境启动：启动Ubuntu，mobaX连接开发板，检查Ubuntu的IP地址和开发板uboot中设置的tftp服务器地址是否一致，不一致使用以下命令修改： setenv serverip 192.168.1.253 检查虚拟机网络设置，VMnet1为net模式，用来虚拟机上网，VMnet0为桥接模式，用来连接开发板挂载。 检查无误后在uboot中输入boot启动 nfs挂载根文件系统目录 ：&#x2F;home&#x2F;wujing&#x2F;linux&#x2F;nfs&#x2F;alientrootfs 应用程序源码存放目录：&#x2F;home&#x2F;wujing&#x2F;Desktop&#x2F;alitenk-test 常用命令： printenv #查看环境变量 boot #启动linux 使能Ubuntu环境变量 source /opt/fsl-imx-x11/4.1.15-2.1.0/environment-setup-cortexa7hf-neon-poky-linux-gnueabi","categories":[{"name":"Linux嵌入式学习","slug":"Linux嵌入式学习","permalink":"https://actorjing.github.io/categories/Linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"2024.1.6姥山岛","slug":"2024-1-6姥山岛","date":"2024-01-13T06:31:41.000Z","updated":"2024-07-05T16:07:02.156Z","comments":true,"path":"2024/01/13/2024-1-6姥山岛/","link":"","permalink":"https://actorjing.github.io/2024/01/13/2024-1-6%E5%A7%A5%E5%B1%B1%E5%B2%9B/","excerpt":"","text":"","categories":[{"name":"摄影日记","slug":"摄影日记","permalink":"https://actorjing.github.io/categories/%E6%91%84%E5%BD%B1%E6%97%A5%E8%AE%B0/"}],"tags":[]},{"title":"FOC学习笔记","slug":"FOC学习笔记","date":"2024-01-13T06:07:09.000Z","updated":"2024-07-05T16:06:42.094Z","comments":true,"path":"2024/01/13/FOC学习笔记/","link":"","permalink":"https://actorjing.github.io/2024/01/13/FOC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"无刷电机驱动原理FOC矢量控制 Park变换","categories":[{"name":"FOC学习","slug":"FOC学习","permalink":"https://actorjing.github.io/categories/FOC%E5%AD%A6%E4%B9%A0/"}],"tags":[]}],"categories":[{"name":"摄影日记","slug":"摄影日记","permalink":"https://actorjing.github.io/categories/%E6%91%84%E5%BD%B1%E6%97%A5%E8%AE%B0/"},{"name":"算法","slug":"算法","permalink":"https://actorjing.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"ARM嵌入式","slug":"ARM嵌入式","permalink":"https://actorjing.github.io/categories/ARM%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"杂项","slug":"杂项","permalink":"https://actorjing.github.io/categories/%E6%9D%82%E9%A1%B9/"},{"name":"论文","slug":"论文","permalink":"https://actorjing.github.io/categories/%E8%AE%BA%E6%96%87/"},{"name":"笔记上传","slug":"笔记上传","permalink":"https://actorjing.github.io/categories/%E7%AC%94%E8%AE%B0%E4%B8%8A%E4%BC%A0/"},{"name":"工作日志","slug":"工作日志","permalink":"https://actorjing.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/"},{"name":"Linux嵌入式学习","slug":"Linux嵌入式学习","permalink":"https://actorjing.github.io/categories/Linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0/"},{"name":"FOC学习","slug":"FOC学习","permalink":"https://actorjing.github.io/categories/FOC%E5%AD%A6%E4%B9%A0/"}],"tags":[]}